<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SimuSphere</title>
<style>
body {
margin: 0;
padding: 40px 20px;
background: linear-gradient(135deg, #0c0c0c, #1a1a1a, #2a2a2a);
color: white;
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
display: flex;
flex-direction: column;
align-items: center;
min-height: 100vh;
text-align: center;
}

.title {
font-size: 2.8rem;
font-weight: 700;
background: linear-gradient(45deg, #4ecdc4, #45b7d1, #7953f2);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
margin-bottom: 8px;
}

.description {
font-size: 16px;
color: #aaa;
margin-bottom: 30px;
max-width: 400px;
line-height: 1.5;
}

/* Loading Overlay */
#loadingOverlay {
position: fixed;
top: 0;
left: 0;
width: 100vw;
height: 100vh;
background: rgba(0, 0, 0, 0.8);
backdrop-filter: blur(5px);
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
z-index: 9999;
color: white;
font-size: 1.5rem;
gap: 1.5rem;
display: none;
}

#loadingOverlay .spinner {
border: 6px solid #333;
border-top: 6px solid #4ecdc4;
border-radius: 50%;
width: 80px;
height: 80px;
animation: spin 1s linear infinite;
}

@keyframes spin {
0% { transform: rotate(0deg); }
100% { transform: rotate(360deg); }
}

.loading-text {
font-weight: 600;
color: #4ecdc4;
text-align: center;
max-width: 300px;
}

/* Modern Drag & Drop Zone */
.dropzone {
width: 400px;
height: 180px;
border: 3px dashed #4ecdc4;
border-radius: 16px;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
color: #4ecdc4;
font-weight: 600;
font-size: 16px;
cursor: pointer;
margin-bottom: 30px;
background: linear-gradient(145deg,
    rgba(78, 205, 196, 0.1),
    rgba(121, 83, 242, 0.15));
box-shadow:
  0 10px 25px rgba(78, 205, 196, 0.2),
  0 0 50px rgba(121, 83, 242, 0.3);
transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
position: relative;
overflow: hidden;
}

.dropzone:hover {
border-color: #45b7d1;
background: linear-gradient(145deg,
    rgba(78, 205, 196, 0.2),
    rgba(121, 83, 242, 0.25));
box-shadow:
  0 15px 35px rgba(78, 205, 196, 0.3),
  0 0 70px rgba(121, 83, 242, 0.4);
transform: translateY(-2px);
}

.dropzone.dragover {
border-color: #7953f2;
background: linear-gradient(145deg,
    rgba(78, 205, 196, 0.3),
    rgba(121, 83, 242, 0.4));
box-shadow:
  0 20px 40px rgba(78, 205, 196, 0.4),
  0 0 80px rgba(121, 83, 242, 0.6);
transform: scale(1.02);
}

.dropzone.has-image {
border-color: #96ceb4;
background: rgba(150, 206, 180, 0.1);
}

.upload-icon {
width: 64px;
height: 64px;
margin-bottom: 16px;
opacity: 0.8;
}

.dropzone-text {
color: #4ecdc4;
font-weight: 600;
}

.preview-image {
width: 100%;
height: 100%;
object-fit: cover;
border-radius: 12px;
position: absolute;
top: 0;
left: 0;
opacity: 0.8;
}

.image-overlay {
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: linear-gradient(145deg,
    rgba(78, 205, 196, 0.8),
    rgba(121, 83, 242, 0.6));
display: flex;
align-items: center;
justify-content: center;
opacity: 0;
transition: opacity 0.3s ease;
border-radius: 12px;
}

.dropzone.has-image:hover .image-overlay {
opacity: 1;
}

.overlay-text {
color: white;
font-weight: 600;
font-size: 14px;
text-align: center;
}

/* Hidden file input */
#fileInput {
display: none;
}

/* Controls */
.controls {
display: flex;
gap: 15px;
justify-content: center;
align-items: center;
margin-bottom: 30px;
flex-wrap: wrap;
max-width: 500px;
}

button {
background: linear-gradient(145deg, #4ecdc4, #45b7d1);
border: none;
color: white;
padding: 14px 24px;
border-radius: 12px;
cursor: pointer;
font-weight: 600;
text-transform: uppercase;
font-size: 12px;
letter-spacing: 0.5px;
min-width: 140px;
transition: all 0.3s ease;
box-shadow: 0 6px 20px rgba(78, 205, 196, 0.4);
}

button:hover:not(:disabled) {
background: linear-gradient(145deg, #45b7d1, #7953f2);
box-shadow: 0 8px 25px rgba(121, 83, 242, 0.6);
transform: translateY(-2px);
}

button:disabled {
opacity: 0.5;
cursor: not-allowed;
transform: none;
box-shadow: none;
}

/* Canvas */
#canvas {
border-radius: 16px;
box-shadow: 
  0 0 60px rgba(78, 205, 196, 0.4),
  0 0 100px rgba(121, 83, 242, 0.3);
display: none;
max-width: 90vw;
max-height: 90vh;
}

/* Image Comparison */
.comparison-container {
display: none;
margin-top: 30px;
padding: 20px;
background: rgba(255, 255, 255, 0.05);
border-radius: 16px;
backdrop-filter: blur(10px);
border: 1px solid rgba(255, 255, 255, 0.1);
max-width: 90vw;
}

.comparison-title {
font-size: 1.5rem;
color: #4ecdc4;
margin-bottom: 20px;
font-weight: 600;
}

.image-comparison {
display: flex;
gap: 20px;
justify-content: center;
align-items: center;
flex-wrap: wrap;
}

.image-section {
display: flex;
flex-direction: column;
align-items: center;
gap: 10px;
}

.image-label {
font-size: 14px;
color: #aaa;
font-weight: 600;
text-transform: uppercase;
letter-spacing: 1px;
}

.comparison-image {
max-width: 300px;
max-height: 300px;
border-radius: 12px;
border: 2px solid rgba(78, 205, 196, 0.3);
box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
}

.vs-text {
font-size: 2rem;
color: #7953f2;
font-weight: 700;
margin: 0 20px;
}

/* Toast Container */
.toast-container {
position: fixed;
top: 20px;
right: 20px;
z-index: 1000;
}

.toast {
background: linear-gradient(145deg, #4ecdc4, #45b7d1);
color: white;
padding: 16px 20px;
border-radius: 12px;
margin-bottom: 10px;
font-weight: 600;
font-size: 14px;
min-width: 250px;
box-shadow: 0 8px 25px rgba(78, 205, 196, 0.4);
transform: translateX(100%);
opacity: 0;
transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
}

.toast.show {
transform: translateX(0);
opacity: 1;
}

.toast.success {
background: linear-gradient(145deg, #96ceb4, #4ecdc4);
}

.toast.complete {
background: linear-gradient(145deg, #ff6b6b, #ffc371);
}

/* Responsive */
@media (max-width: 768px) {
body {
  padding: 20px 10px;
}

.title {
  font-size: 2.2rem;
}

.dropzone {
  width: 90%;
  height: 160px;
}

.controls {
  flex-direction: column;
  gap: 10px;
}

button {
  width: 100%;
  max-width: 280px;
}

.image-comparison {
  flex-direction: column;
}

.vs-text {
  margin: 10px 0;
}

.comparison-image {
  max-width: 250px;
  max-height: 250px;
}

.toast-container {
  top: 10px;
  right: 10px;
  left: 10px;
}

.toast {
  min-width: auto;
}

#loadingOverlay .spinner {
  width: 60px;
  height: 60px;
}

.loading-text {
  font-size: 1.2rem;
}
}
</style>
</head>
<body>

<h1 class="title">SimuSphere</h1>
<p class="description">This project recreates your image with spheres in a physics-based simulation. Drag & drop your image or click below to upload.</p>

<div id="dropzone" class="dropzone" tabindex="0">
  <svg class="upload-icon" viewBox="0 0 24 24" fill="currentColor">
    <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
    <path d="M12,11L16,15H13V19H11V15H8L12,11Z"/>
  </svg>
  <div class="dropzone-text">Drop your image here or click to browse</div>
  <div class="image-overlay">
    <div class="overlay-text">Click to change image<br>or drop a new one</div>
  </div>
  <input type="file" id="fileInput" accept="image/*">
</div>

<div class="controls">
  <button id="startBtn" disabled>Start Simulation</button>
  <button id="downloadBtn" style="display: none;">Download Result</button>
</div>

<canvas id="canvas" width="900" height="900"></canvas>

<div class="comparison-container" id="comparisonContainer">
  <div class="comparison-title">Before & After Comparison</div>
  <div class="image-comparison">
    <div class="image-section">
      <div class="image-label">Original Image</div>
      <img id="originalImage" class="comparison-image" alt="Original">
    </div>
    <div class="vs-text">VS</div>
    <div class="image-section">
      <div class="image-label">Sphere Recreation</div>
      <canvas id="resultImage" class="comparison-image" width="300" height="300"></canvas>
    </div>
  </div>
</div>

<div class="toast-container" id="toastContainer"></div>

<!-- Loading Overlay -->
<div id="loadingOverlay">
  <div class="spinner"></div>
  <div class="loading-text">Calculating ball positions and physics...<br>This may take a few moments</div>
</div>

<script>
const WIDTH = 900;
const HEIGHT = 900;
const GRAVITY = { x: 0, y: 981 };
const BOUNCE_LOSS = 0.9;
const COLLISION_DAMPING = 0.95;
const MIN_RADIUS = 6;
const MAX_RADIUS = 24;
const SPAWN_STEP_INTERVAL = 1;
const FIXED_DT = 1/60.0;
const TOTAL_STEPS = 1000;
const SIMULATION_SUBSTEPS = 8;
const MAX_OBJECTS = 1000;
const CELL_SIZE = MAX_RADIUS * 2;

let randomSeed = 42;
function seededRandom() {
    const x = Math.sin(randomSeed++) * 10000;
    return x - Math.floor(x);
}

function showLoading() {
    document.getElementById('loadingOverlay').style.display = 'flex';
}

function hideLoading() {
    document.getElementById('loadingOverlay').style.display = 'none';
}

function showToast(message, type = 'info') {
    const toastContainer = document.getElementById('toastContainer');
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.textContent = message;
    
    toastContainer.appendChild(toast);
    
    setTimeout(() => {
        toast.classList.add('show');
    }, 100);
    
    setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
            if (toastContainer.contains(toast)) {
                toastContainer.removeChild(toast);
            }
        }, 400);
    }, 3000);
}

class Vector2 { 
    constructor(x = 0, y = 0) { this.x = x; this.y = y;} 
    add(o){return new Vector2(this.x+o.x,this.y+o.y);} 
    subtract(o){return new Vector2(this.x-o.x,this.y-o.y);} 
    multiply(s){return new Vector2(this.x*s,this.y*s);} 
    divide(s){return new Vector2(this.x/s,this.y/s);} 
    lengthSquared(){return this.x*this.x+this.y*this.y;} 
    length(){return Math.sqrt(this.lengthSquared());} 
    normalize(){const len=this.length();if(len===0)return new Vector2(0,0);return this.divide(len);} 
    copy(){return new Vector2(this.x,this.y);} 
}

class Ball {
    constructor(position, radius, stepAdded, color = null) {
        this.position = new Vector2(position.x, position.y);
        this.oldPosition = new Vector2(position.x, position.y);
        this.acceleration = new Vector2(0, 0);
        this.radius = radius;
        this.mass = Math.PI * radius * radius;
        this.stepAdded = stepAdded;
        this.color = color || `rgb(${Math.floor(100 + seededRandom() * 155)}, ${Math.floor(100 + seededRandom() * 155)}, ${Math.floor(100 + seededRandom() * 155)})`;
    }
    
    update(dt) {
        const velocity = this.position.subtract(this.oldPosition);
        this.oldPosition = this.position.copy();
        this.position = this.position.add(velocity).add(this.acceleration.multiply(dt * dt));
        this.acceleration = new Vector2(0, 0);
    }
    
    accelerate(force) {
        if (this.mass > 0) {
            this.acceleration = this.acceleration.add(new Vector2(GRAVITY.x, GRAVITY.y));
        }
    }
    
    applyConstraints() {
        if (this.position.x - this.radius < 0) { 
            this.position.x = this.radius; 
        } else if (this.position.x + this.radius > WIDTH) { 
            this.position.x = WIDTH - this.radius; 
        }
        if (this.position.y - this.radius < 0) { 
            this.position.y = this.radius; 
        } else if (this.position.y + this.radius > HEIGHT) { 
            this.position.y = HEIGHT - this.radius; 
        }
    }
    
    draw(ctx) {
        const gradient = ctx.createRadialGradient(
            this.position.x - this.radius/3,
            this.position.y - this.radius/3,
            0,
            this.position.x,
            this.position.y,
            this.radius
        );
        gradient.addColorStop(0, this.color);
        gradient.addColorStop(1, this.adjustBrightness(this.color, -30));
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.position.x, this.position.y, this.radius, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.fillStyle = this.adjustBrightness(this.color, 50);
        ctx.beginPath();
        ctx.arc(this.position.x - this.radius/4, this.position.y - this.radius/4, this.radius/6, 0, 2 * Math.PI);
        ctx.fill();
    }
    
    adjustBrightness(color, amount) {
        const match = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (match) {
            const r = Math.max(0, Math.min(255, parseInt(match[1]) + amount));
            const g = Math.max(0, Math.min(255, parseInt(match[2]) + amount));
            const b = Math.max(0, Math.min(255, parseInt(match[3]) + amount));
            return `rgb(${r}, ${g}, ${b})`;
        }
        return color;
    }
}

class Simulation {
    constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.balls = [];
        this.currentStep = 0;
        this.isRunning = false;
        this.grid = new Map();
        this.inputImage = null;
        this.imageData = null;
        this.ballSpawnData = [];
        this.frameCount = 0;
        this.lastTime = 0;
        this.fps = 60;
        this.phase = 'idle';
        this.displayStep = 0;
        this.ballsSpawned = 0;
        
        this.setupEventListeners();
        this.draw();
    }
    
    setupEventListeners() {
        const startBtn = document.getElementById('startBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const fileInput = document.getElementById('fileInput');
        const dropzone = document.getElementById('dropzone');
        
        startBtn.addEventListener('click', () => this.start());
        downloadBtn.addEventListener('click', () => this.downloadImage());
        fileInput.addEventListener('change', (e) => this.loadImage(e));
        
        // Drag and drop functionality
        dropzone.addEventListener('click', () => fileInput.click());
        
        dropzone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropzone.classList.add('dragover');
        });
        
        dropzone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dropzone.classList.remove('dragover');
        });
        
        dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropzone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files && files.length > 0) {
                this.handleFile(files[0]);
            }
        });
    }
    
    showImagePreview(file) {
        const dropzone = document.getElementById('dropzone');
        const uploadIcon = dropzone.querySelector('.upload-icon');
        const dropzoneText = dropzone.querySelector('.dropzone-text');
        
        // Remove existing preview image if any
        const existingPreview = dropzone.querySelector('.preview-image');
        if (existingPreview) {
            existingPreview.remove();
        }
        
        // Create image preview
        const img = document.createElement('img');
        img.className = 'preview-image';
        img.src = URL.createObjectURL(file);
        
        // Add the preview image to dropzone
        dropzone.appendChild(img);
        
        // Hide upload icon and text, show overlay
        uploadIcon.style.display = 'none';
        dropzoneText.style.display = 'none';
        dropzone.classList.add('has-image');
    }
    
    handleFile(file) {
        if (!file || !file.type.startsWith('image/')) {
            showToast('Please select a valid image file', 'error');
            return;
        }
        
        // Show image preview immediately
        this.showImagePreview(file);
        
        const img = new Image();
        img.onload = () => {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = WIDTH;
            tempCanvas.height = HEIGHT;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(img, 0, 0, WIDTH, HEIGHT);
            this.imageData = tempCtx.getImageData(0, 0, WIDTH, HEIGHT);
            this.inputImage = img;
            
            document.getElementById('startBtn').disabled = false;
            
            showToast('Image loaded successfully!', 'success');
        };
        img.src = URL.createObjectURL(file);
    }
    
    loadImage(event) {
        const file = event.target.files[0];
        if (file) {
            this.handleFile(file);
        }
    }
    
    getCellIndex(position) {
        return {
            x: Math.floor(position.x / CELL_SIZE),
            y: Math.floor(position.y / CELL_SIZE)
        };
    }
    
    updateGrid() {
        this.grid.clear();
        for (const ball of this.balls) {
            const cell = this.getCellIndex(ball.position);
            const key = `${cell.x},${cell.y}`;
            if (!this.grid.has(key)) {
                this.grid.set(key, []);
            }
            this.grid.get(key).push(ball);
        }
    }
    
    getNearbyBalls(ball) {
        const cell = this.getCellIndex(ball.position);
        const nearbyBalls = [];
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                const key = `${cell.x + dx},${cell.y + dy}`;
                if (this.grid.has(key)) {
                    nearbyBalls.push(...this.grid.get(key));
                }
            }
        }
        return nearbyBalls;
    }
    
    solveCollisions() {
        this.updateGrid();
        for (const ball1 of this.balls) {
            const nearbyBalls = this.getNearbyBalls(ball1);
            for (const ball2 of nearbyBalls) {
                if (ball1 === ball2) continue;
                
                const collisionAxis = ball1.position.subtract(ball2.position);
                const distSq = collisionAxis.lengthSquared();
                const minDist = ball1.radius + ball2.radius;
                
                if (distSq < minDist * minDist && distSq > 0) {
                    const dist = Math.sqrt(distSq);
                    const normal = collisionAxis.divide(dist);
                    const overlap = (minDist - dist) * 0.5;
                    const totalMass = ball1.mass + ball2.mass;
                    const massRatio1 = totalMass === 0 ? 0.5 : ball2.mass / totalMass;
                    const massRatio2 = totalMass === 0 ? 0.5 : ball1.mass / totalMass;
                    const separationVector = normal.multiply(overlap);
                    ball1.position = ball1.position.add(separationVector.multiply(massRatio1 * COLLISION_DAMPING));
                    ball2.position = ball2.position.subtract(separationVector.multiply(massRatio2 * COLLISION_DAMPING));
                }
            }
        }
    }
    
    update(dt) {
        const subDt = dt / SIMULATION_SUBSTEPS;
        for (let i = 0; i < SIMULATION_SUBSTEPS; i++) {
            for (const ball of this.balls) {
                ball.accelerate(GRAVITY);
            }
            this.solveCollisions();
            for (const ball of this.balls) {
                ball.applyConstraints();
                ball.update(subDt);
            }
        }
    }
    
    addBall(ball) {
        if (this.balls.length < MAX_OBJECTS) {
            this.balls.push(ball);
        } else if (this.balls.length > 0) {
            this.balls.shift();
            this.balls.push(ball);
        }
    }
    
    calculatePositions() {
        console.log("Starting calculation phase...");
        this.phase = 'calculating';
        
        randomSeed = 42;
        this.balls = [];
        this.ballSpawnData = [];
        this.currentStep = 0;
        let ballsSpawned = 0;
        
        while (this.currentStep < TOTAL_STEPS) {
            if (this.currentStep % SPAWN_STEP_INTERVAL === 0 && ballsSpawned < MAX_OBJECTS) {
                const centerPos = new Vector2(WIDTH/2, HEIGHT/2);
                const radius = MIN_RADIUS + seededRandom() * (MAX_RADIUS - MIN_RADIUS);
                const newBall = new Ball(centerPos, radius, this.currentStep);
                
                const angle = seededRandom() * 2 * Math.PI;
                const blastSpeed = 40;
                const velocity = new Vector2(
                    Math.cos(angle) * blastSpeed,
                    Math.sin(angle) * blastSpeed
                );
                newBall.oldPosition = newBall.position.subtract(velocity.multiply(FIXED_DT));
                
                this.ballSpawnData.push({
                    step: this.currentStep,
                    x: newBall.position.x,
                    y: newBall.position.y,
                    radius: newBall.radius,
                    oldX: newBall.oldPosition.x,
                    oldY: newBall.oldPosition.y,
                    color: newBall.color
                });
                
                this.addBall(newBall);
                ballsSpawned++;
            }
            
            this.update(FIXED_DT);
            this.currentStep++;
        }
        
        if (this.imageData) {
            console.log("Mapping colors from input image...");
            this.mapBallsToImage();
        }
        
        console.log("Calculation phase complete!");
    }
    
    mapBallsToImage() {
        if (!this.imageData) return;
        
        const sortedBalls = [...this.balls].sort((a, b) => a.stepAdded - b.stepAdded);
        
        for (let i = 0; i < Math.min(sortedBalls.length, this.ballSpawnData.length); i++) {
            const ball = sortedBalls[i];
            const x = Math.max(0, Math.min(WIDTH - 1, Math.floor(ball.position.x)));
            const y = Math.max(0, Math.min(HEIGHT - 1, Math.floor(ball.position.y)));
            const index = (y * WIDTH + x) * 4;
            const r = this.imageData.data[index];
            const g = this.imageData.data[index + 1];
            const b = this.imageData.data[index + 2];
            const a = this.imageData.data[index + 3];
            
            if (a > 128) {
                this.ballSpawnData[i].color = `rgb(${r}, ${g}, ${b})`;
            }
        }
    }
    
    displaySimulation() {
        console.log("Starting display phase...");
        this.phase = 'displaying';
        
        // Hide loading overlay when starting display
        hideLoading();
        showToast('Starting simulation display...', 'info');
        
        this.balls = [];
        this.displayStep = 0;
        this.ballsSpawned = 0;
        this.isRunning = true;
        
        this.displayLoop(performance.now());
    }
    
    displayLoop(currentTime) {
        if (!this.isRunning) return;
        
        if (currentTime - this.lastTime >= 1000) {
            this.fps = this.frameCount;
            this.frameCount = 0;
            this.lastTime = currentTime;
        }
        this.frameCount++;
        
        while (this.ballsSpawned < this.ballSpawnData.length && 
               this.ballSpawnData[this.ballsSpawned].step === this.displayStep) {
            const data = this.ballSpawnData[this.ballsSpawned];
            const newBall = new Ball(
                new Vector2(data.x, data.y),
                data.radius,
                data.step,
                data.color
            );
            newBall.oldPosition = new Vector2(data.oldX, data.oldY);
            
            if (this.balls.length < MAX_OBJECTS) {
                this.balls.push(newBall);
            } else if (this.balls.length > 0) {
                this.balls.shift();
                this.balls.push(newBall);
            }
            
            this.ballsSpawned++;
        }
        
        this.update(FIXED_DT);
        this.draw();
        
        this.displayStep++;
        
        if (this.displayStep < TOTAL_STEPS) {
            requestAnimationFrame((time) => this.displayLoop(time));
        } else {
            this.stop();
        }
    }
    
    draw() {
        const gradient = this.ctx.createLinearGradient(0, 0, 0, HEIGHT);
        gradient.addColorStop(0, '#000000');
        gradient.addColorStop(1, '#111111');
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, WIDTH, HEIGHT);
        
        for (const ball of this.balls) {
            ball.draw(this.ctx);
        }
    }
    
    start() {
        if (this.isRunning) return;
        
        // Show loading overlay immediately
        showLoading();
        
        this.canvas.style.display = 'block';
        
        document.getElementById('startBtn').disabled = true;
        
        // Use setTimeout to allow loading overlay to render
        setTimeout(() => {
            this.calculatePositions();
            
            // Start display phase after a brief delay
            setTimeout(() => {
                this.displaySimulation();
            }, 500);
        }, 100);
    }
    
    showComparison() {
        if (!this.inputImage) return;
        
        // Show original image
        const originalImg = document.getElementById('originalImage');
        originalImg.src = this.inputImage.src;
        
        // Show result image
        const resultCanvas = document.getElementById('resultImage');
        const resultCtx = resultCanvas.getContext('2d');
        resultCanvas.width = 300;
        resultCanvas.height = 300;
        
        // Scale and draw the current simulation
        const scale = 300 / WIDTH;
        resultCtx.scale(scale, scale);
        
        const gradient = resultCtx.createLinearGradient(0, 0, 0, HEIGHT);
        gradient.addColorStop(0, '#000000');
        gradient.addColorStop(1, '#111111');
        resultCtx.fillStyle = gradient;
        resultCtx.fillRect(0, 0, WIDTH, HEIGHT);
        
        for (const ball of this.balls) {
            const ballGradient = resultCtx.createRadialGradient(
                ball.position.x - ball.radius/3,
                ball.position.y - ball.radius/3,
                0,
                ball.position.x,
                ball.position.y,
                ball.radius
            );
            ballGradient.addColorStop(0, ball.color);
            ballGradient.addColorStop(1, ball.adjustBrightness(ball.color, -30));
            resultCtx.fillStyle = ballGradient;
            resultCtx.beginPath();
            resultCtx.arc(ball.position.x, ball.position.y, ball.radius, 0, 2 * Math.PI);
            resultCtx.fill();
            
            resultCtx.fillStyle = ball.adjustBrightness(ball.color, 50);
            resultCtx.beginPath();
            resultCtx.arc(ball.position.x - ball.radius/4, ball.position.y - ball.radius/4, ball.radius/6, 0, 2 * Math.PI);
            resultCtx.fill();
        }
        
        // Show comparison container
        document.getElementById('comparisonContainer').style.display = 'block';
    }
    
    stop() {
        this.isRunning = false;
        this.phase = 'complete';
        
        document.getElementById('downloadBtn').style.display = 'inline-block';
        
        // Show comparison
        this.showComparison();
        
        showToast('ðŸŽ‰ Simulation Complete! You can now download the result.', 'complete');
        
        console.log('Simulation completed with', this.balls.length, 'balls');
    }
    
    downloadImage() {
        const exportCanvas = document.createElement('canvas');
        const exportCtx = exportCanvas.getContext('2d');
        exportCanvas.width = WIDTH * 2;
        exportCanvas.height = HEIGHT * 2;
        exportCtx.scale(2, 2);
        
        const gradient = exportCtx.createLinearGradient(0, 0, 0, HEIGHT);
        gradient.addColorStop(0, '#000000');
        gradient.addColorStop(1, '#111111');
        exportCtx.fillStyle = gradient;
        exportCtx.fillRect(0, 0, WIDTH, HEIGHT);
        
        for (const ball of this.balls) {
            const gradient = exportCtx.createRadialGradient(
                ball.position.x - ball.radius/3,
                ball.position.y - ball.radius/3,
                0,
                ball.position.x,
                ball.position.y,
                ball.radius
            );
            gradient.addColorStop(0, ball.color);
            gradient.addColorStop(1, ball.adjustBrightness(ball.color, -30));
            exportCtx.fillStyle = gradient;
            exportCtx.beginPath();
            exportCtx.arc(ball.position.x, ball.position.y, ball.radius, 0, 2 * Math.PI);
            exportCtx.fill();
            
            exportCtx.fillStyle = ball.adjustBrightness(ball.color, 50);
            exportCtx.beginPath();
            exportCtx.arc(ball.position.x - ball.radius/4, ball.position.y - ball.radius/4, ball.radius/6, 0, 2 * Math.PI);
            exportCtx.fill();
        }
        
        exportCtx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        exportCtx.font = '16px Arial';
        exportCtx.textAlign = 'right';
        exportCtx.fillText('Made with SimuSphere', WIDTH - 20, HEIGHT - 20);
        
        const link = document.createElement('a');
        link.download = `simu_sphere_${Date.now()}.png`;
        link.href = exportCanvas.toDataURL('image/png');
        link.click();
        
        showToast('High-resolution image downloaded!', 'success');
    }
}

window.addEventListener('load', () => {
    new Simulation();
});
</script>
</body>
</html>
